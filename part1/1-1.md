服务注册阶段主要分为两个过程，一是Server启动，二是服务发布。

通过Spring Schema配置或者通过@Service注解的形式配置Pigeon的Provider服务，启动服务时都会首先初始化ServiceBean并调用其init\(\)方法进行服务注册。ServiceBean中的配置属性值通过Spring Schema或@Service注解进行设置。

##### ServiceBean：

```java
public void init() throws Exception {
    ServerConfig serverConfig = new ServerConfig();
    serverConfig.setPort(port);
    serverConfig.setAutoSelectPort(autoSelectPort);
    serverConfig.setCorePoolSize(corePoolSize);
    serverConfig.setMaxPoolSize(maxPoolSize);
    serverConfig.setWorkQueueSize(workQueueSize);
    serverConfig.setEnableTest(enableTest);
    List<ProviderConfig<?>> providerConfigList = new ArrayList<ProviderConfig<?>>();
    for (String url : services.keySet()) {
        ProviderConfig<Object> providerConfig = new ProviderConfig<Object>(services.get(url));
        providerConfig.setUrl(url);
        providerConfig.setServerConfig(serverConfig);
        providerConfig.setCancelTimeout(cancelTimeout);
        providerConfigList.add(providerConfig);
    }

    // 进行服务注册
    ServiceFactory.addServices(providerConfigList);
}
```

通过Provider初始化配置，设置ProviderConfig并调用ServiceFactory.addServices，此过程也可以通过手工编码的方式来进行服务启动和注册。

在ServiceFactory.addServices中会遍历ProviderConfig，并逐条调用PublishPolicy.doAddService来启动Server监听和服务的注册，这个过程是整个服务注册过程的核心部分

PublishPolicy是一个SPI扩展点，Pigeon默认情况下使用DefaultPublishPolicy来进行处理，如果我们需要定制化这块处理则可以添加SPI定义来覆盖DefaultPublishPolicy的处理

##### AbstractPublishPolicy：

```java
@Override
public void doAddService(ProviderConfig providerConfig) {
    try {
        // 校验服务名定义是否合法，是否使用了预留的服务名定义
        checkServiceName(providerConfig);
        // 设置ProviderConfig和URL的映射，服务实现类的所有方法和URL的映射
        ServicePublisher.addService(providerConfig);
        // 启动Server监听，默认情况下Pigeon将根据ServerConfig中的Protocol定义来选择启动NettyServer还是JettyHttpServer
        ServerConfig serverConfig = ProviderBootStrap.startup(providerConfig);
        providerConfig.setServerConfig(serverConfig);
        // 将Provider的服务信息发布到注册中心，默认情况下Pigeon使用Zookeeper作为注册中心
        ServicePublisher.publishService(providerConfig, false);
    } catch (Throwable t) {
        throw new RpcException("error while adding service:" + providerConfig, t);
    }
}
```

在PublishPolicy中主要处理Server启动和服务注册，如果Provider实现类实现了接口InitializingService，则在ServicePublisher.addService中会进行初始化调用

##### ServicePublisher：

```java
public static <T> void addService(ProviderConfig<T> providerConfig) throws Exception {
    ... 省略 ...

    T service = providerConfig.getService();
    if (service instanceof InitializingService) {
        ((InitializingService) service).initialize();
    }

    ... 省略 ...
}
```

ProviderBootstrap是启动Service过程中的核心类

##### ProviderBootstrap：

```java
public static ServerConfig startup(ProviderConfig<?> providerConfig) {
    ServerConfig serverConfig = providerConfig.getServerConfig();
    if (serverConfig == null) {
        throw new IllegalArgumentException("server config is required");
    }
    Server server = serversMap.get(serverConfig.getProtocol() + serverConfig.getPort());
    if (server != null) {
        server.addService(providerConfig);
        return server.getServerConfig();
    } else {
        synchronized (ProviderBootStrap.class) {
            List<Server> servers = ExtensionLoader.newExtensionList(Server.class);
            for (Server s : servers) {
                if (!s.isStarted()) {
                    // Protocol支持，default使用NettyServer，http使用JettyHttpServer
                    if (s.support(serverConfig)) {
                        s.start(serverConfig);
                        s.addService(providerConfig);
                        serversMap.put(s.getProtocol() + serverConfig.getPort(), s);
                        logger.warn("pigeon " + s + "[version:" + VersionUtils.VERSION + "] has been started");
                        break;
                    }
                }
            }
            server = serversMap.get(serverConfig.getProtocol() + serverConfig.getPort());
            if (server != null) {
                server.getRequestProcessor().getRequestProcessThreadPool().prestartAllCoreThreads();
                return server.getServerConfig();
            }
            return null;
        }
    }
}
```

启动Server时会同时创建请求处理器，用以处理客户端、心跳、心跳扫描和健康检查等的请求

##### AbstractServer：

```java
public void start(ServerConfig serverConfig) {
    if (logger.isInfoEnabled()) {
        logger.info("server config:" + serverConfig);
    }
    // 选择请求处理器
    requestProcessor = RequestProcessorFactory.selectProcessor();
    doStart(serverConfig);
    if (requestProcessor != null) {
        // 启动请求处理的线程池
        requestProcessor.start(serverConfig);
    }
    this.serverConfig = serverConfig;
}
```

在Pigeon中，RequestProcessor是一个SPI扩展点，用于创建请求处理器。默认情况下，RequestThreadPoolProcessor作为请求处理器。

##### RequestThreadPoolProcessor：

```java
@Override
public void doStart() {
    synchronized (RequestThreadPoolProcessor.class) {
        try {
            if (sharedRequestProcessThreadPool == null) {
                sharedRequestProcessThreadPool = new DynamicThreadPool("Pigeon-Server-Request-Processor",
                        serverConfig.getCorePoolSize(), serverConfig.getMaxPoolSize(), serverConfig.getWorkQueueSize(),
                        new ThreadPoolExecutor.AbortPolicy(), false, false);
            } else {
                sharedRequestProcessThreadPool.setCorePoolSize(serverConfig.getCorePoolSize());
                sharedRequestProcessThreadPool.setMaximumPoolSize(serverConfig.getMaxPoolSize());
                sharedRequestProcessThreadPool.setWorkQueueCapacity(serverConfig.getWorkQueueSize());
            }
        } catch (Throwable t) {
            logger.error("error serverConfig args: " + serverConfig + ", please check...", t);
            System.exit(-1);
        }
    }
}
```



